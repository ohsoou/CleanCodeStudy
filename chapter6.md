
# 객체와 자료구조

### 자료의 추상화

변수 사이에 함수라는 계층을 넣는다고 구현이 감춰지지 않는다.

조회 함수(get)와 설정 함수(set)로 변수를 다룬다고 클래스가 되지 않는다.

그보다 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.

### 자료 / 객체 비대칭

객체와 자료구조는 근본적으로 양분된다.

> (자료구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
>   __절차적(자료구조) 코드 -> 함수 추가 효율     ||     객체지향 코드 -> 클래스 추가 효율__

> 절차적인 코드는 새로운 자료구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.
>   __절차적(자료구조) 코드 -> 자료구조 추가 비효율     ||     객체지향 코드 -> 함수 추가 비효율__

### 디미터 법칙

잘 알려진 휴리스틱(heuristic).

모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙

객체는 조회함수로 내부를 공개하면 안된다.

클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출

<br>

  - 클래스 C
  - f가 생성한 객체
  - f 인수로 넘어온 객체
  - C 인스턴스 변수에 저장된 객체
 
<br>

```
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```
위와 같은 코드를 _기차 충돌(train werck)_ 이라고 한다. 쓰지 않는게 좋다.

```
final String outputDir = ctxt.options.scratchDir.absolutePath;
```
위와 같이 구현하면 객체인지, 자료구조인지 따지지 않아도 되고, 디미터 법칙도 위반하지 않는다.

자료구조는 무조건 함수 없이 공개 변수만 포함하도록 만들고 객체는 비공개 변수와 공개 함수를 포함하면 더 구분하기 쉬울 것이다.

하지만 단순한 자료 구조에도 get/ set 함수를 설정해야하는 법칙이 있는 프레임워크와 표준(ex. Bean)도 있다.

자료구조 방식과 객체 방식을 섞은 _잡종 구조_ 는 둘의 단점만 모아놓는 구조다. 사용을 지양한다.



### 자료 전달 객체

자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다.

이런 자료구조체를 때로 _Data Transfer Object, DTO_ 라고 한다. 흔히 데이터베이스에 저장된 정보를 어플리케이션 코드에서 사용할 객체로 변환할 때 가장 처음으로 사용하는 구조체다.

좀 더 일반적으로 _빈(Bean) 구조_ 다. 빈은 비공개 변수를 조회/ 설정 함수로 조작한다.

_활성 레코드_ 는 DTO의 특수한 형태다. 공개변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료구조지만, save나 find 같은 탐색 함수도 제공한다. 이는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다. 활성 레코드는 잡종 구조가 나오기 쉽다. 활성 레코드는 자료 구조로, 비지니스 규칙을 담으면서 내부 자료(대부분 활성 레코드의 인스턴스)를 숨기는 객체는 따로 생성한다. 
